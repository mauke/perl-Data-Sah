# just to make PodWeaver happy at the moment
package Data::Sah::Manual::Schema;

=head1 NAME

Data::Sah::Manual::Schema - Description of Sah schema language


=head1 OVERVIEW AND TERMINOLOGY

Although it can contain extra stuff, a B<schema> is essentially a type
definition, stating a set of valid values for data. Sah defines several basic
types like "bool", "int", "str", "array", "hash", and a few others. Please see
B<Data::Sah::Type::*> for the complete list.

A type can have B<clauses>, which mostly declare constraints. Each clause has a
B<clause name> and a B<clause value>. For example: min => 10. Or: between => [1,
10]. When validating a data, each clause will be tested and must succeed for the
whole validation to succeed. Aside from declaring constraints, clauses can also
declare other stuff like default value (the "default" clause), store metadata
(the "summary", "description", "tags" clauses), etc. Please see type's
documentation for the list of known clauses of each type.

B<Clause set> is just a term for a hash of clauses. A Sah schema is essentially
comprised of type name and one or more clause sets (Sah allows you to have
multiple clause sets per type).

B<Clause attribute>. Aside from having value, a clause can also have attributes,
which is a hash of attribute names and values. It's just a way to associate more
than a single data into a clause. Clause attributes are used for various
functions. See L</"CLAUSE"> for more information on clause attributes.

B<Base schema>. You can define a schema, declare it as a new type, and then
write subsequent schemas against that type, along with additional clauses. This
is very much like subtyping. See L</"BASE SCHEMA"> and L</"CLAUSE"> for more
information.


=head2 GENERAL STRUCTURE

Sah schema is just a regular hash:

 {
  type        => TYPE,
  clause_sets => [CLAUSE_SET, ...],
  def         => {BASE_NAME => BASE_SCHEMA, ...}
 }

Example:

 {type => 'int',
  clause_sets => [{min=>1, max=>10}],
  def => {}}

Aside from the above normalized form (also sometimes called the third form or
the hash form), Sah accepts various other shortcuts for convenience. These
alternative forms will be normalized to the above form before processing.

If you only have one clause set, you can write (saves typing a pair of
brackets):

 {type => 'int',
  clause_sets => {min=>1, max=>10},
  def => {}}

If you don't have any base schema definition, which is very common, you can use
the array form (or the so-called second form) to save even some typing:

 [int => {min=>1, max=>10}]

I expect the array form to be the majority that people will write. Also, if you
only have one clause set which is common, you can omit the hash to further save
typing a pair of curly braces:

 ["int", min=>1, max=>10]

If you don't have any clauses, you can use the scalar/string form (or the
so-called first form):

 "int"

=head2 String form shortcuts

For convenience, the string form not only can be used to specify just type, but
also some common clauses via shortcut syntax:

=over 4

=item * The * suffix (req=>1)

 "X*"

is equivalent to:

 [X => {req=>1}]

Where "req" is the clause that declares that value is required. Examples:

 "int*"            # [int => {req=>1}]

=item * The [] suffix (array of)

 "X[]"

is equivalent to:

 [array => {of => X}]

where "of" is the clause that specifies the single schema for each element of
the array. Examples:

 "int[]"           # [array => {of=>"int"}]
 "(int*)[]"        # [array => {of=>[int => {req=>1}]}]
 "((int*)[])*"     # [array => {of=>[int => {req=>1}], req=>1}]

An optional number or two can be given to specify required array length:

 "X[N]"            # array of exactly N elements in length
 "X[N-]"           # array of at least N elements in length
 "X[-N]"           # array of at most N elements in length
 "X[N-M]"          # array of between N and M elements in length

Examples:

 "str[2]"          # [array => {of=>'str', len=>2}]
 "str[1-]"         # [array => {of=>'str', min_len=>1}]
 "str[-20]"        # [array => {of=>'str', max_len=>20}]
 "str[10-20]"      # [array => {of=>'str', min_len=>10, max_len=>20}]

=item * The [a, b] notation (schema for element)

 "[A, B]"

is equivalent to:

 [array, {elems => [A, B]}]

where "elems" is the clause to specify schemas for each array element,
corresponding with the position (so A is the schema for the first element of the
array, B for the second, and so on). Examples:

 "[int, str, array]" # [array => {elems=>['int', 'str', 'array']}]
 "[int*, str[]]"     # [array => {elems=>[[int => {req=>1}],
                     #                    [array => {of=>'str'}]]}]
 "[str, str]*"       # [array => {elems=>['str', 'str'], req=>1}]

=item * The a|b notation (either)

 "A|B|C"

is equivalent to:

 [any => {of => [A, B, C]}]

"any" is a type where its "of" clause means that data must comply to any one of
the schemas specified. Example:

 "hash|array"      # [any => {of=>["hash", "array"]}]
 "(int|(int*)[])*" # [any => {of=>["int", [array=>{of=>[int=>{req=>1}]}]],
                   #          req=>1}]

=item * The a&b notation (all)

This is just like "a|b" notation, but for specifying 'all' instead of 'any'.

"all" is a type where its "of" clause means that data must comply to all of the
schemas specified. Example:

 "int & regex"    # [all => {of=>["int", "regex"]}]

=item * The {key=>sch} notation (hash keys)

 "{X=>Y, ...}"

is equivalent to:

 [hash => {keys => {X=>Y}}]

A special value for X, B<*>, can be used to mean all keys. The "keys" clause
specify known hash keys as well as schema for each of those keys. Example:

 "{a=>hash, b=>int*, c=>str[]}" # [hash => {keys=>{a=>'hash',
                                #                  b=>[int=>{req=>1}],
                                #                  c=>[array=>{of=>'str'}]}}]
 "{*=>int}"                     # [hash => {values_of => 'int'}]

=back


=head1 BASE SCHEMA

As mentioned before, you can define a schema as a type and then write other
schemas against that type. For example:

 # defined as pos_int type
 [int => {min=>0}]

and later:

 # a positive integer, divisible by 5
 [pos_int => {div_by=>5}]

During data validation, all base schemas will be replaced by its original
definition, so the above schema will become:

 [int => {min=>0} => {div_by=>5}]

In other words, the clause sets are just appended.

In hash form schema, you can also declare base schemas/types locally using the
B<def> key, for example:

 {
  def => {
      single_dice_throw  => [int => {in => [1,2,3,4,5,6]}],
      sdt                => "single_dice_throw", # short notation
      dice_pair_throw    => [array => {len=>2, elems=>["sdt", "sdt"]}],
      dpt                => "dice_pair_throw",   # short notation
      throw              => [any => {of => ["sdt", "dpt"]}],
      throws             => [array => {of => "throw"}],
  },
  type => "throws"
 }

The above schema describes a list of dice throws ("throws"). Each B<throw> can
be a single dice throw ("sdt") which is a number between 1 and 6, OR a throw of
two dices ("dpt") which is a 2-element array (where each element is a number
between 1 and 6).

Examples of valid data for this schema:

 [1, [1,3], 6, 4, 2, [3,5]]

Examples of invalid data:

 1                  # not an array
 [1, [2, 3], 0]     # the third throw is invalid
 [1, [2, 0, 4], 4]  # the second throw is invalid

All the base schemas names "throw", "throws", "sdt", etc is only declared
locally and unknown outside the schema. You can even nest this.

=head2 Optional/conditional definition

If you put a C<?> suffix after the definition name then it means that the
definition is optional and can be skipped if the type is already defined, e.g.:

 {
  def         => {
      "email?"   => [str => {req=>1, match=>".+\@.+"}],
      "username" => [str => {req=>1, match=>'^[a-z0-9_]+$'}],
  },
  type        => "hash",
  clause_sets => [{req=>1, keys_of=>"username", values_of=>"email"}],
 }

In the above example, if there is already an "email" type defined at that time,
the definition will be skipped instead of a "cannot redefine type" error being
generated.

Optional definition is useful if you want to provide some defaults (e.g. a
rudimentary validation for email) but don't mind if the validator already has
something probably better (a stricter or more precise definition of email).


=head1 CLAUSE

A clause set is a mapping of clause names and values, or clause attributes and
their values:

 {
   clause1 => value,
   clause2 => value,
   "clause2:attr1" => value,
   "clause2:attr2" => value,
   ...
 }

Each type has its own set of known clauses and each clause has a set of known
attributes. See type documentation (e.g. L<Data::Sah::Type::hash> for hash type)
for the list of known clauses and clause attributes of that type.

When doing validation, all clauses will be evaluated and must succeed if the
validation is to succeed. The order of evaluation usually does not matter, but
some clauses are early (like "default" and "prefilters") and some are late (like
"postfilters").

A schema can specify more than one clause sets, in which each clause set will be
evaluated in order. will be evaluated in order. However, if a key on one clause
set (except for the first) contains a merge prefix, merging will occur first
(see L</"Clause set merging">).

=head2 Clause name

Clause names must begin with letter/underscore and contain
letters/numbers/underscores only. All clauses which begin with an "_"
(underscore) will be ignored by Sah (you can use this to embed extra data for
other purposes).

=head2 Clause attribute

You can specify attribute for a clause with the following syntax:

 { 'CLAUSE_NAME:ATTR_NAME' => ATTRVALUE,
   ... }

Attribute name must also only contain letters/numbers/underscores, but it can a
dotted-separated series of parts, e.g. C<lang.ind> or C<a.b.c>. As with clauses,
clause attributes which begin with "_" (underscore) will be ignored by Sah.

Clause attribute give additional information/instruction associated with the
attribute. Below are some common clause attributes:

=over 4

=item * err_level

Valid value: C<error>, C<warn>. Default if not specified is C<error>. Normally,
when clause checking fails, an error is generated and the fails to validate the
whole schema. If B<err_level> is set to C<warn>, however, this only generates a
warning and does not cause the validation to fail.

 [str=>{min_len=>4},
       {min_len=>8, 'min_len:err_level' => 'warn'},]

Example:

 # password
 [str =>
   {req                 => 1,
    min_len             => 4},
   {min_len             => 8,
    "min_len:err_level" => "warn",
    "min_len:err_msg"   => "Although a password less than 4 letters are ".
                           "valid it's highly recommended that a password is ".
                           "at least 8 letters long, for security reasons"}],

In the above example, the "err_level" and "err_msg" are attributes for the
"min_len" clause. The second clause set basically adds an optional restriction
for the password: when the "min_len" clause is not satisfied, instead of making
the data fails the validation, only a warning is issued.

=item * err_msg[.LANGCODE]

This tells the compiler that instead of the default error message from the type
handler, a custom error message is supplied. LANG is 2- or 3-code ISO language
code and can be omitted (to mean the default/fallback language). For example:

 [str=>{match               => qr/[^A-Za-z0-9_-]/,
        'match:err_msg'     => 'Must not contain naughty characters',
        'match:err_msg.ind' => 'Tidak boleh mengandung karakter aneh-aneh',
 }]

=item * comment

This is ignored during validation.

=item * human[.LANGCODE]

This is also ignored when validating data, but will be used by the
L<Data::Sah::Compiler::human> compiler to supply description. LANG is a 2- or
3-code ISO language code and can be omitted (to mean the default/fallback
language).

 [str=>{match             => qr/[^A-Za-z0-9_-]/,
        'match:human.eng' => 'Must not contain naughty characters',
 }]

=item * alt

This attribute is used to store alternative clause value. Examples are:

 alt.lang.<LANGCODE>

to store alternative value for different language. This applies to clauses which
contain a translatable text, like B<name>, B<summary>, B<description>.

=item * expr

Used to specify expression. See L<"/EXPRESSION"> for more information. There is
a shortcut for this attribute using the '=' clause suffix. Example:

 [str => {'min_len:expr' => '2*3'}]

is equivalent to:

 [str => {'min_len=' => '2*3'}]

=back

=head2 Special-purpose clauses

Normally clauses serve as a type constraint (e.g. for type string, the "min_len"
and "max_len" clauses restrict how short/long the string can be). However there
are also some clauses that are special.

=head3 The '' (empty clause)

This can be used to store attributes that can be used generally by other clauses
("general attributes"). For example:

 [str => {not_match => /(password|abcd)$/,
          min_len => 4,
          ":err_msg" => "Password not good enough!"}]

When validation fails for one or more of the clauses, the custom error message
will be used instead.

=head2 Clause set merging

Given several clause sets in the schema like:

 [TYPE, CS1, CS2, CS3]

all CS1, CS2, and CS3 will be evaluated in that order:

 eval(CS1)
 eval(CS2)
 eval(CS3)

However, if a clause set hash contains one or more keys with merge prefix
(explained later), the clause set will first be merged with the previous clause
set(s) prior to evaluation. For example, if CS2 keys contain merge prefixes
(notation: "*" indicates the presence of merge prefix):

 [TYPE, CS1, *CS2, CS3]

then CS1 will be merged with CS2 first before evaluated (notation: "~" signifies
merging).

 eval(CS1 ~ *CS2)
 eval(CS3)

If CS3 instead contains merge prefixes:

 [TYPE, CS1, CS2, *CS3]

then CS1 will be evaluated, and then CS2 is merged first with CS3:

 eval(CS1)
 eval(CS2 ~ *CS3)

If CS2 as well as CS3 contains merge prefixes:

 [TYPE, CS1, CS2*, *CS3]

then the three will be merged first before evaluating:

 eval(CS1 ~ *CS2 ~ *CS3)

So in short, unless the right hand side is devoid of merge prefixes, merging
will be done first from left to right.

The first clause set should not contain any merge prefixes.

Sah uses L<Data::ModeMerge> to do the merging. In merging, Data::ModeMerge
allows keys on the right side hash not only to replace but also add, subtract,
remove keys from the left side. This is powerful because it allows schema
definition to not only add clauses (restrict types even more), but also replace
clauses (change type restriction) as well as delete clauses (relax type
restriction). For more information, refer to the Data::ModeMerge documentation.

Examples:

 [int => {div_by=>2}, {  div_by =>3}] # must be divisible by 2 & 3

 [int => {div_by=>2}, {'*div_by'=>3}] # will be merged and become:
 [int => {div_by=>3}                ] # must be divisible by 3 ONLY

 [int => {div_by=>2}, {'!div_by'=>0}] # will be merged and become:
 [int => {}                         ] # need not be divisible by any number

 [int => {in=>[1,2,3,4,5]}, {  in =>[6]}] # impossible to satisfy

 [int => {in=>[1,2,3,4,5]}, {'+in'=>[6]}] # will be merged and become:
 [int => {in=>[1,2,3,4,5,6]}            ]

 [int => {in=>[1,2,3,4,5]}, {'-in'=>[4]}] # will be merged and become:
 [int => {in=>[1,2,3,  5]}              ]

=head3 Merging and hash keys

XXX: Does merging of clause sets need to be done recursively?

Due to recursive merging of clause sets by L<Data::ModeMerge>, please be
reminded if your clause set keys contain a merge prefix, then you need to check
all hashes (not just the top-level clause set hash, but also deep down in nested
hashes) for possible accidental merge prefixes:

 + - . ! *

because they will also be merged and B<removed> after merging.

Example:

 [hash => { "keys_regex" => { foo => [int=>{max=>7}], "^bar.*" => "str" }}
       => {"*keys_regex" => {-foo => [int=>{max=>3}]                    }}]

will be merged to:

 [hash => { "keys_regex" => { foo => [{max=>7}], "bar.*" => "str" }}]

that is, foo will also gets merged. Sometimes this might be what you want, but
sometimes it might not be. If the later is the case, you can turn off prefix
parsing:

 [hash => { "keys_regex" => { foo => [int=>{max=>7}], "^bar.*" => "str",
                              ""=>{parse_prefix=>0} }}
       => {"*keys_regex" => {-foo => [int=>{max=>4}]}}]

it will become:

 [hash => { "keys_regex" => { foo => [int=>{max=>7}], -foo => [int=>{max=>4}],
                              "^bar.*" => "str" } }];

C<^> is quite common as the first character in regexes. As an alternative you
can use C<\A> which will be safe in merges.

Please also note that the empty string key ("") is also regarded as special by
L<Data::ModeMerge>, it is called the options key which regulate how merging
should be done. Be careful not to use an empty string as your key either.

XXX: You can turn off clause set merging by setting Sah's B<merge_clause_sets>
attribute to false?


=head1 EXPRESSION

XXX: Syntax of variables not yet fixed.

Sah supports expressions, using L<Language::Expr> minilanguage. See
L<Language::Expr::Manual::Syntax> for details on the syntax. You can specify
expression in the B<check> clause, e.g.:

 [int => {check => '${data:.} >= 4'}]

Alternatively, expression can also be specified in any clause's attribute:

 [int => {'min:expr' => '2+2'}]
 [int => {'min='     => 'floor(4.9)'}]

The above three schemas are equivalent to:

 [int => {min => 4}]

Expression can refer to elements of data and (normalized) schema, and can call
functions, enabling more complex schema to be defined, for example:

 ['array*' => {len=>2, elems => [
   ['str*', {match => '^\w+$'}],
   ['str*', {'match:expr' => '${../../0/clause_sets/0/match}',
             'min_len:expr' => '2*length(${data:../0})'}]
 ]}]

The above schema requires data to be a two-element array containing strings,
where the length of the second string has to be at least twice the length of the
first. Both strings have to comply to the same regex, qr/^\w+$/ (which is
declared on the first string's clause and referred to in the second string's
clause).


=head1 FUNCTION

Functions can be used in expressions. The syntax of calling function is:

 func()
 func(ARG, ...)

For the list of functions supported, see L<Data::Sah::FuncSet::Core>. To add a
new Sah function set from Perl, see L<Data::Sah::Manual::NewFuncSet>.

Functions in Sah can sometimes accept several types of arguments, e.g.
length(ARRAY) will return the number of elements in the ARRAY, while length(STR)
will return the number of characters in the string. However, when an
inappropriate argument is given, a Perl exception will be thrown.


=head1 SEE ALSO

L<Data::Sah::Manual::NewType> for guide on creating a new type.

L<Data::Sah::Manual::NewClause> for guide on extending an existing type by
adding a new clause.

L<Data::Sah::Manual::NewFuncSet> for guide on creating a new function set.

Want more schema examples? Try L<Data::Sah::Manual::Cookbook>.

=cut
