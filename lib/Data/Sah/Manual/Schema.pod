# just to make PodWeaver happy at the moment
package Data::Sah::Manual::Schema;

=pod

=head1 NAME

Sah::Manual::Schema - Description of Sah schema system


=head1 OVERVIEW AND TERMINOLOGY

Although it can contain extra stuff, a B<schema> is essentially a type
definition, stating a set of valid values for data. Sah defines several basic
types like "bool" ("boolean"), "int" ("integer"), "str" ("string"), "array",
"hash", and a few others. Please see Sah::Schema::Type::* for the complete list.

A type can have B<clauses>, which mostly declare constraints. Examples include
"min" ("minimum") and "max" ("maximum") clauses to declare minimum and maximum
values, or str's "match" clause to specify a regex pattern that value must match.
Clauses can also declare other stuff like default value (the "default" clause),
etc. Please see type's documentation for the list of known clauses of each type.
Below are several schemas, each specifying a basic type and zero or more clauses:

 # an integer, with no clauses
 'int'

 # same thing
 [integer => {}]

 # a positive integer
 [int => {min=>0}]

 # a positive, even integer
 [int => {min=>0, divisible_by=>2}]

 # an integer that must be divisible by 2 and 3
 [int => {divisible_by=>2}, {divisible_by=>3}]

 # a leap year: divisible by 4 and (not divisible by 100 unless divisible by 400)
 [int => {divisible_by=>4, if => [divisible_by => 100, divisible_by => 400]]

B<Clause set> is just a hash of clauses. Sah allows you to have multiple clause
sets per type. In the previous examples, the second last example has two clause
sets.

B<Clause attribute>. Aside from having a value (like in C<"divisible_by" => 2>
clause, "divisible_by" is the clause name and 2 is the clause value), a clause
can also have attributes. Clause attributes are used for various function. See
L</"CLAUSE"> for more information on clause attributes.

B<Subschema>. You can define some schema as a new type and then form a new schema
based on the previous schema along with some additional clauses. This is very
much like subtyping. The difference in Sah is that a subschema can be defined
locally (only known inside the declaring schema) and that a subschema can
actually replace and I<remove> clauses (i.e. relax instead of just further
restrict the set of valid values). See L</"SUBSCHEMA"> and L</"CLAUSE"> for more
information.


=head2 GENERAL STRUCTURE

Sah schema is just a regular hash:

 {
  type        => TYPE,
  clause_sets => [CLAUSE_SET, ...],
  def         => {SUBSCHEMA_NAME => SUBSCHEMA_DEFINITION, ...}
 }

Aside from the above normalized form, Sah accepts various other shortcuts for
convenience. These alternative forms will be normalized to the above form before
processing.

If you only have a single clause set, which is the common case, you can specify
it in the "clauses" key instead of "clause_sets":

 {type => ..., clauses => ...}

Example:

 {type=>'int', clauses=>{min=>1, max=>10}}

If you don't have any subschema definition, which is also very common, you can
use the array form to save some typing:

 [TYPE, CLAUSE_SET, ...]

Example:

 [int => {min=>1, max=>10}]

You can even omit the hash to further save typing a couple of curly braces:

 ["int", min=>1, max=>10]

If you don't have any clauses, you can use the scalar (string) form:

 "int"

=head2 String form shortcuts

The string form actually supports some shortcut syntax for common clauses:

=over 4

=item * The * suffix (required/set=1)

 "X*"

equivalent to:

 [X => {required => 1}]

Examples:

 "int*"            # [int => {required=>1}]

=item * The [] suffix (array of)

 "X[]"

is equivalent to:

 [X => {of => "int"}]

Examples:

 "int[]"           # [array => {of=>"int"}]
 "(int*)[]"        # [array => {of=>[int => {required=>1}]}]
 "((int*)[])*"     # [array => {of=>[int => {required=>1}], required=>1}]

An optional number or two can be given to specify required array length:

 "X[N]"            # array of exactly N elements in length
 "X[N-]"           # array of at least N elements in length
 "X[-N]"           # array of at most N elements in length
 "X[N-M]"          # array of between N and M elements in length

Examples:

 "str[2]"          # [array => {of=>'str', len=>2}]
 "str[1-]"         # [array => {of=>'str', minlen=>1}]
 "str[-20]"        # [array => {of=>'str', maxlen=>20}]
 "str[10-20]"      # [array => {of=>'str', minlen=>10, maxlen=>20}]

=item * The [a, b] notation (schema for element)

 "[A, B]"

is equivalent to:

 [array, {elems => [A, B]}]

The "elems" clause specifies schema for each array element.

Examples:

 "[int, str, array]" # [array => {elems=>['int', 'str', 'array']}]
 "[int*, str[]]"   # [array => {elems=>[[int => {required=>1}], [array => {of=>'str'}]]}]
 "[str, str]*"     # [array => {elems=>['str', 'str'], required=>1}]

=item * The a|b notation (either)

 "A|B"

is equivalent to:

 [either => {of => [A, B, C]}]

Example:

 "hash|array"      # [either => {of=>["hash", "array"]}]
 "(int|(int*)[])*" # [either => {of=>["int", [array=>{of=>[int=>{required=>1}]}]], required=>1}]

=item * The a&b notation (all)

This is just like "a|b" notation, but for specifying 'all' instead of 'either'.

=item * The {key=>sch} notation (hash keys)

 "{X=>Y}"

is equivalent to:

 [hash => {keys => {X=>Y}}]

A special value for X, B<*>, can be used to mean all keys.

Example:

 "{a=>hash, b=>int*, c=>str[]}" # [hash => {keys=>{a=>'hash', b=>[int=>{required=>1}], c=>[array=>{of=>'str'}]}}]
 "{*=>int}"        # [hash => {values_of => 'int'}]

=back


=head1 SUBSCHEMA

You can define a new type from a schema. To do this, call the define_type():

 $sah->define_type(posint => [int => {min=>0}]);

Or, to define locally, use the "def" key:

 {
  def => {
      single_dice_throw  => [int => {one_of => [1,2,3,4,5,6]}],
      sdt                => "single_dice_throw", # short notation
      dice_pair_throw    => [array => {len=>2, elems=>["sdt", "sdt"]}],
      dpt                => "dice_pair_throw",   # short notation
      throw              => [either => {of => ["sdt", "dpt"]}],
      throws             => [array => {of => "throw"}],
  },
  type => "throws"
 }

The above schema describes a list of dice throws ("throws"). Each B<throw> can be
a single dice throw ("sdt") which is a number between 1 and 6, OR a throw of two
dices ("dpt") which is a 2-element array (where each element is a number between
1 and 6).

Examples of valid data:

 [1, [1,3], 6, 4, 2, [3,5]]

Examples of invalid data:

 1                  # not an array
 [1, [2, 3], 0]     # the third throw is invalid
 [1, [2, 0, 4], 4]  # the second throw (a dice pair throw) is invalid

All the subschema names "throw", "throws", "sdt", etc is only declared locally
and is unknown outside the schema. You can even nest this.

=head2 Optional/conditional definition

If you put a C<?> suffix after the subschema name then it means that the
definition is optional and can be skipped if the type is already defined, e.g.:

 {
  def     => {
      "email?"   => [str => {set=>1, match=>".+\@.+"}],
      "username" => [str => {set=>1, match=>'^[a-z0-9_]+$'}], },
  type    => "hash",
  clauses => {set=>1, keys_of=>"username", values_of=>"email"},
 }

In the above example, if there is already an 'email' type defined at that time,
the definition will be skipped instead of a "type already exists" error being
generated.

Globally, it is equivalent to:

 unless ($sah->type_defined($type)) {
     $sah->define_type($type, ...);
 }

Optional definition is useful if you want to provide some defaults (e.g. a
rudimentary validation for email) but don't mind if the validator already has
something probably better (a stricter or more precise definition of email).


=head1 CLAUSE

A clause set or clause hash is a mapping of clause names and values, or clause
attributes and their values:

 {
   clause1 => value,
   clause2 => value,
   "clause2:attr1" => value,
   "clause2:attr2" => value,
   ...
 }

Each type has its own set of known clauses and each clause has a set of known
attributes. See type documentation (e.g. L<Data::Sah::Type::Hash> for hash type) for
the list of known clauses and clause attributes of that type.

When doing validation, all clauses will be evaluated and must succeed if the
validation is to succeed. The order of evaluation usually does not matter, but
some clauses are early (like "default" and "prefilters") and some are late (like
"postfilters").

A schema can specify more than one clause sets, in which each clause set will be
evaluated in order. will be evaluated in order. However, if a key on one clause
set (except for the first) contains a merge prefix, merging will occur first (see
L</"Clause set merging">).

=head2 Clause name

Clause names must begin with letter/underscore and contain
letters/numbers/underscores only. All clauses which begin with an "_"
(underscore) will be ignored by Sah (you can use this to embed extra data for
other purposes).

=head2 Clause attribute

You can specify attribute for a clause with the following syntax:

 { 'CLAUSE_NAME:ATTR_NAME' => ATTRVALUE,
   ... }

As with clauses, clause attributes which begin with "_" (underscore) will be
ignored by Sah.

Clause attribute give additional information/instruction associated with the
attribute. Below are some common clause attributes:

=over 4

=item * errlevel

Valid value: C<error>, C<warn>. Default if not specified is C<error>. Normally,
when clause checking fails, an error is generated and the fails to validate the
whole schema. If B<errlevel> is set to C<warn>, however, this only generates a
warning and does not cause the validation to fail. See previous

Example:

 [str=>{minlen=>4},
       {minlen=>8, 'minlen:errlevel' => 'warn'},]
Example:

 # password
 [str =>
   {req               => 1,
    minlen            => 4},
   {minlen            => 8,
    "minlen:errlevel" => "warn",
    "minlen:errmsg"   => "Although a password less than 4 letters are valid, ".
                         "it's highly recommended that a password is at least ".
                         "8 letters long, for security reasons"}],

In the above example, the "errlevel" and "errmsg" are attributes for the "minlen"
clause. The second clause set basically adds an optional restriction for the
password: when the "minlen" clause is not satisfied, instead of making the data
fails the validation, only a warning is issued.

=item * errmsg[.LANG]

This tells the emitter that instead of the default error message from the type
handler, a custom error message is supplied. LANG is 2-code language code and can
be omitted (to mean the default/fallback language). For example:

 [str=>{match             => qr/[^A-Za-z0-9_-]/,
        'match:errmsg'    => 'Must not contain naughty characters',
        'match:errmsg.id' => 'Tidak boleh mengandung karakter aneh-aneh',
 }]

=item * comment

This is ignored during validation.

=item * human[.LANG]

This is also ignored when validating data, but will be used by the
L<Data::Sah::Emitter::Human> emitter to supply description. LANG is a 2-code language
code and can be omitted (to mean the default/fallback language).

 [str=>{match            => qr/[^A-Za-z0-9_-]/,
        'match:human.en' => 'Must not contain naughty characters',
 }]

=item * expr

Used to specify expression. See L<"/EXPRESSION"> for more information. There is a
shortcut for this attribute using the '=' clause suffix. Example:

 [str => {'minlen:expr' => '2*3'}]

is equivalent to:

 [str => {'minlen=' => '2*3'}]

=back

=head2 Special-purpose clauses

Normally clauses serve as a type constraint (e.g. for type string, the "minlen"
and "maxlen" clauses restrict how short/long the string can be). However there
are also some clauses that are special.

=head3 The '' (empty clause)

This can be used to store attributes that can be used generally ("general
attributs"). For example:

 [str => {not_match => /(password|abcd)$/,
          minlen => 4,
          ":errmsg" => "Password not good enough!"}]

When validation fails for one or more of the clauses, the custom error message
will be used instead.

=head2 Clause set merging

Given several clause sets in the schema like:

 [TYPE, CS1, CS2, CS3]

all CS1, CS2, and CS3 will be evaluated in that order:

 eval(CS1)
 eval(CS2)
 eval(CS3)

However, if a clause set hash contains one or more keys with merge prefix
(explained later), the clause set will first be merged with the previous clause
set(s) prior to evaluation. For example, if CS2 keys contain merge prefixes
(notation: "*" indicates the presence of merge prefix):

 [TYPE, CS1, *CS2, CS3]

then CS1 will be merged with CS2 first before evaluated (notation: "~" signifies
merging).

 eval(CS1 ~ *CS2)
 eval(CS3)

If CS3 instead contains merge prefixes then CS1 will be evaluated, and then CS2
is merged first with CS3:

 eval(CS1)
 eval(CS2 ~ *CS3)

If CS2 as well as CS3 contains merge prefixes, then the three will be merged
first before evaluating:

 eval(CS1 ~ *CS2 ~ *CS3)

So in short, unless the right hand side is devoid of merge prefixes, merging will
be done first from left to right.

The first clause set should not contain any merge prefixes.

Sah uses L<Data::ModeMerge> to do the merging. In merging, Data::ModeMerge allows
keys on the right side hash not only to replace but also add, subtract, remove
keys from the left side. This allows schema definition to not only add clauses
(restrict types even more), but also replace clauses (change type restriction) as
well as delete clauses (relax type restriction). For more information, refer
to the Data::ModeMerge documentation.

Examples:

 [int => {divisible_by=>2}, {  divisible_by =>3}] # must be divisible by 2 & 3

 [int => {divisible_by=>2}, {'*divisible_by'=>3}] # will be merged and become:
 [int => {divisible_by=>3}                      ] # must be divisible by 3 ONLY

 [int => {divisible_by=>2}, {'!divisible_by'=>0}] # will be merged and become:
 [int => {}                                     ] # need not be divisible at all

 [int => {one_of=>[1,2,3,4,5]}, {  one_of =>[6]}] # impossible to satisfy

 [int => {one_of=>[1,2,3,4,5]}, {'+one_of'=>[6]}] # will be merged and become:
 [int => {one_of=>[1,2,3,4,5,6]}                ]

 [int => {one_of=>[1,2,3,4,5]}, {'-one_of'=>[4]}] # will be merged and become:
 [int => {one_of=>[1,2,3,  5]}                  ]

=head3 Merging and hash keys

Due to merging of clause sets by L<Data::ModeMerge>, please be reminded that
whenever there is one of these prefix characters on any hash key (not just on
clause names, but also deep down in nested hashes):

 + - . ! *

they will be B<removed> after merging.

Example:

 [hash => { "keys_regex" => { foo => [int=>{max=>7}], "^bar.*" => "str" }}
       => {"*keys_regex" => {-foo => [int=>{max=>3}]                    }}]

will be merged to:

 [hash => { "keys_regex" => { foo => [{max=>7}], "bar.*" => "str" }}]

that is, foo will also gets merged. Sometimes this might be what you want, but
sometimes it might not be. If the later is the case, you can turn off prefix
parsing:

 [hash => { "keys_regex" => { foo => [int=>{max=>7}], "^bar.*" => "str",
                              ""=>{parse_prefix=>0} }}
       => {"*keys_regex" => {-foo => [int=>{max=>4}]}}]

it will become:

 [hash => { "keys_regex" => { foo => [int=>{max=>7}], -foo => [int=>{max=>4}], "^bar.*" => "str" } }];

C<^> is quite common as the first character in regexes. As an alternative you can
use C<\A> which will be safe in merges.

Please also note that the empty string key ("") is also regarded as special by
L<Data::ModeMerge>, it is called the options key which regulate how merging
should be done. Be careful not to use an empty string as your key either.

You can turn off clause set merging by setting Sah's B<merge_clause_sets>
attribute to false.


=head1 EXPRESSION

(XXX Syntax of variables not yet fixed.)

Sah supports expressions, using L<Language::Expr> minilanguage. See
L<Language::Expr::Manual::Syntax> for details on the syntax. You can specify
expression in the B<check> clause, e.g.:

 [int => {check => '${data:.} >= 4'}]

Alternatively, expression can also be specified in a clause attribute:

 [int => {'min:expr' => '2+2'}]
 [int => {'min='     => 'floor(4.9)'}]

The above three schemas are equivalent to:

 [int => {min => 4}]

Expression can refer to elements of data and (normalized) schema, and can call
functions, enabling more complex schema to be defined, for example:

 ['array*' => {len=>2, elements => [
   ['str*', {match => '^\w+$'}],
   ['str*', {'match:expr' => '${../../0/clause_sets/0/match}',
             'len:expr' => '2*length(${data:../0})'}]
 ]}]

The above schema requires data to be a two-element array containing strings,
where the length of the second string has to be exactly twice the length of the
first, but not longer than the third string. Both have to comply to the same
regex, qr/^\w+$/.


=head1 FUNCTION

Functions can be used in expressions. The syntax of calling function is:

 func()
 func(ARG, ...)

For the list of functions supported, see L<Data::Sah::Spec::Func::Std>. To add a new
Sah function from Perl, see L<Data::Sah::Manual::Function>.

Functions in Sah can sometimes accept several types of arguments, e.g.
length(ARRAY) will return the number of elements in the ARRAY, while length(STR)
will return the number of characters in the string. However, when an
inappropriate argument is given, a Perl exception will be thrown.


=head1 SEE ALSO

L<Data::Sah::Manual::Function> for more on functions.


=cut
