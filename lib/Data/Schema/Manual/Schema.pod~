# just to make PodWeaver happy at the moment
package Data::Schema::Manual::Schema;

=pod

=head1 NAME

Data::Schema::Manual::Schema - Data::Schema schema reference


=head1 OVERVIEW

This document is explains the syntax of Data::Schema schema.


=head1 FORMS

Data::Schema schema is just a normal data structure: Perl scalars,
arrays, and hashes.

There are three forms of schema. These different forms are supported
for the convenience of schema writers. Internally all schemas and
subschemas will be converted ("normalized") to the third form (HASH).

=head2 First Form (SCALAR)

 TYPE

The simplest form of schema is just a scalar (string) specifying type
name. This states that the data must be of specified type

With this first form you cannot add any other value restrictions or anything
else, so this form is very limited.

Example:

 "int"

The schema says that data must be an integer. Examples of valid data:

 5
 -2
 undef

Note: undef is always valid except when we explicitly say that we
require a value. This is analogous to NULL in SQL is always allowed as
column values except when the column is specified with NOT NULL.

Example of invalid data:

 "int"  # not an integer, but a string
 [1]    # not an integer, an array
 {}     # not an integer, an empty hash

TYPE can also be the name of another schema. For example if you already have
defined a schema with name 'short_array' with this definition:

 [array => {maxlen => 10}]

Then you can also have a schema that says just:

 short_array

and it will also mean that the data must satisfy the 'short_array' schema.

=head2 Second Form (ARRAY)

 [TYPE, ATTRHASH, ATTRHASH, ...]

The second form is the array form. The first element of the array is
required, the type name (or schema name). The rest is a list of attribute
hashes, and is optional.

The first form is actually equivalent to this second form:

 [TYPE]

in which no attribute hashes are specified.

Attribute hash is a mapping of attribute names and values. This
further limits the range of data values possible. Each type has its
own set of known attributes, for example all numeric types (like B<int> and
B<float>) has the B<min>, B<max>, et al. Most types have a B<one_of> attribute
to limit values to the list of values we specify, etc.

For type validation to succeed, the type requirement *as well as* the
requirements of all attributes (from all attribute hashes) must be
satisfied.

For more details on attribute hashes, see B<ATTRHASH> section below.

Example:

 [str => {one_of => [qw/A B O AB/]}]

This schema states that data must be a string, and it must either be "A", "B",
"O", or "AB". Examples of invalid data:

 []    # does not satisfy type requirement, not a string
 "C"   # a string value, but does not satisfy the one_of attribute

Another example:

 ["int", {set=>1, min=>0, divisible_by=>2}, {divisible_by=>3}]

The schema effectively says that the data must be positive and divisible by 6
(since it must be divisible by 2 AND 3). Examples of valid data:

 6
 12

Examples of invalid data:

 -6      # an int, satisfies all divisible_by attributes, but not the min
 undef   # set=>1 is specified so undef is not allowed

If you specify a schema name as the first element, then the attributes will be
of the base type of the schema. Example:

 # schema with name = 'even'
 [int => {divisible_by=>2}]

 # our schema
 [even => {min=>20}]

Our schema in effect says that the data must be an even number greater or equal
than 20. Since our schema is based on the B<even> schema, the attributes we can
specify is that of the B<int> type, since B<even> is defined as an int.

=head3 Shortcut notation in first form

Previously it is stated that the first form (SCALAR) cannot add any
restrictions. This is not entirely true. As of Data::Schema 0.15, some
shortcut notations in the first form is allowed.

=head4 * suffix (required/set=1)

The B<set => 1> attribute is very often used, so a shortcut is
provided. Instead of writing:

 [int => {set=>1}]

you can also say:

 "int*"

They are equivalent, as the shortcut notation will be converted to the
array form.

=head4 [] suffix (array of)

 "int[]"

is a shorter way to say:

 [array => {of => "int"}]

Other example:

 "(int*)[]"        # [ array => {of=> [int=>{set=>1}]         } ]
 "((int*)[])*"     # [ array => {of=> [int=>{set=>1}], set=>1 } ]

=head4 [a, b, c] notation

 "[int, str]"

is a shorter way to say:

 [array => {elems => ['int', 'str']}]    # meaning, 1st elem must be an int, 2nd must be a str

Other examples:

 "[int*, str[]]"  # [ array => {elems => [ [int=>{set=>1}], [array=>{of=>'str'}] ]} ]
 "[str, str]*"    # [ array => {elems => ['str', 'str'], set=>1} ]

=head4 a|b notation (either)

 "str|array|hash"

is a shorter way to say:

 [either => {of => ['str', 'array', 'hash']}]

Other examples:

 "(int|(int*)[])*"   # [ either => {of => [ 'int', [array=>{of=>[int=>{set=>1}]}] ], set=>1} ]

=head4 a&b notation (all)

This is just like "a|b" notation, but for specifying 'all' instead of 'either'.

=head4 {key=>sch} notation (hash keys)

 "{a=>hash, b=>int*, c=>str[]}"

is a shorter way to say:

 [hash => {keys=>{a=>'hash', b=>[int=>{set=>1}], c=>[array=>{of=>'str'}]}}]

A special key, B<*>, can be used to mean all keys. "{*=>int}" is equivalent to:

 [hash => {values_of => 'int'}]


=head2 Third Form (HASH)

 {type=>TYPE OR SCHEMA,
  attrs=>ATTRHASH, attr_hashes=>[ATTRHASH, ...],
  def=>SCHEMADEFS,
  ...}

The third form (HASH) is the most complete form where you can specify
everything. The B<type> key is required, while the rest are
optional.

The second form is equivalent to this third form:

 {type=>TYPE, attr_hashes=>[ATTRHASH, ...]}

where nothing but type name and attribute hashes are specified.

The first form is equivalent to this third form:

 {type=>TYPE}

where nothing but type name is specified.

You can specify attribute hashes in B<attr_hashes> key, or if you want
to specify just one attribute hash, you can use the B<attrs> key. If
they are both present, attribute hashes from both will be used.

This third form allows us to define other schemas inside our schema, using the
B<def> keys, which must be a hashref of schema name and definition. This is a
way to break down or organize a complex schema into several pieces.

Example:

 {
  def => {
      Single_dice_throw    => [int => {one_of => [1,2,3,4,5,6]}],
      Sdt                  => "Single_dice_throw", # short notation
      Dice_pair_throw      => [array => {len=>2, elems=>["Sdt", "Sdt"]}],
      Dpt                  => "Dice_pair_throw",   # short notation
      Throw                => [either => {of => ["Sdt", "Dpt"]}],
      Throws               => [array => {of => "Throw"}],
  },
  type => "Throws"
 }

This schema specifies that we are accepting a list of dice throws
(B<Throws>). Each B<Throw> can be a single dice throw (B<Sdt>) which
is a number between 1 and 6, OR a throw of two dices (B<Dpt>) which is
a 2-element array (where each element is a number between 1 and 6).

(Btw, it is recommended to use B<MixedCase> for schema/subschema name,
to avoid clashing with future builtin types.)

Examples of valid data:

 [1, [1,3], 6, 4, 2, [3,5]]

Examples of invalid data:

 [1, [2, 3], 0]     # the third throw is invalid
 [1, [2,0,4], 4, 5] # the second throw (a dice pair throw) is invalid

=head2 Optional/conditional definition

If you put a C<?> prefix before the subschema name then it means that
the definition is optional and can be skipped if the type/subschema
is already defined, e.g.:

 { def => {
       "?Email"   => [str => {set=>1, match=>".+\@.+"}],
       "Username" => [str => {set=>1, match=>'^[a-z0-9_]+$'}],

       "Data" => [hash => {set=>1, keys_of=>"Username", values_of=>"Email"}],
   },
   type => "Data"
 }

In the above example, if there is already an 'Email' type or subschema
defined at that time, the definition will be skipped instead of a
"type already exists" error being generated. This is analogous, for
example, to CREATE TABLE IF NOT EXISTS in MySQL.

Optional definition is useful if you want to provide some defaults (a
basic validation for email) but don't mind if the validator already
has something probably better (a stricter or more precise definition
of email).

=head1 TYPE

Data::Schema comes with several types out of the box, for example:
B<bool>, B<int>, B<float>, B<str>, B<array>, B<hash>, etc.

Each type is handled by a type handler, which is a Perl module.

For more details on each type, refer to its handler module
documentation. For example, for B<hash> type, see
L<Data::Schema::Type::Hash>.

You can write your own type handler. For more information on how to
write a type handler, see L<Data::Schema::Manual::TypeHandler>.


=head1 ATTRHASH

An attribute hash is a mapping of attribute names and values:

 {
   "<Prefix><Name><?Params>" => value,
   ...
 }

Example:

 {
   ^min => 0,
   "min?errmsg" => "Only positive numbers are accepted",
   max => 100,
 }

Each type has its own set of known attribute names. To see what
attributes a type supports, see type handler module documentation. For
example, for B<hash> type, see L<Data::Schema::Type::Hash>.

A schema can specify more than one attribute hashes, in which each
attribute hash will be evaluated in order. However, if a key on one
attribute hash contains a prefix (see B<Attribute prefix> section
below), merging will occur (see B<Merging of attribute hashes> section
below).

=head1 Attribute name

Attribute names must begin with letter/underscore and contain
letters/numbers/underscores only. All attributes which begin with an
underscore will be ignored.

=head2 Attribute prefix

Attribute prefix is one of these characters:

 + - . ! *

prepended to the attribute name.

These will affect merging behaviour of attribute hashes.

The first attribute hash in the schema is not allowed to have
attribute prefixes on its keys.

=head2 Attribute parameters

Attribute parameters is written much like query string in URL, using
question mark ("?") followed by a list of (parameter name, equal sign
["="], and parameter value) separated by "&". URL escaping is done to
allow special characters.

Attribute parameters give additional information/instruction
associated with the attribute.

There is a list of known parameter names. A schema is invalid if it
contains an unknown attribute parameter name.

=head3 level

Valid value: error, warn. Default is error. Normally, when attribute
checking fails, an error is generated and the whole schema fails to
validate. If level is set to warn, however, this only generates a
warning and does not cause the validation to fail.

=head3 err

Shortcut for level=error.

=head3 warn

Shortcut for level=warn.

Example:

[str=>{minlen        => 4,
       "minlen?warn" => 8}]

In the above example, validation fails when data is shorter than 4
characters. When the data is between 4-7 characters, validation
succeeds with a warning.

=head3 errmsg

This attribute parameter is used to supply custom error message. For
example:

 [str=>{regex=>'^\w{4,8}$',
        'regex?errmsg&lang=en'=>'4-8 alphanumeric characters only!'}]

When validation of the B<regex> attribute fails, instead of the
default error message from type handler, validator will use the custom
error message giving clearer information to the user.

If you don't use lang=XX parameter, it will be assumed to be a
translation string and will be passed to the translation system.

=head3 warnmsg

Just like errmsg but for warnings. For example:

 [str=>{minlen          =>4,
        'minlen?warn'   =>8,
        'minlen?warnmsg&lang=en' => 'password shorter than 8 letters is ok, but not recommended'}]

=head3 comment

They will be ignored during validation. You can use it to document your
schema if you want.

 [hash,
  { '?comment' => "this schema validates event record",
    required_keys => [qw/time place parties/],
    'required_keys?comment' => "at least date, time, place, and participants must be specified",
    keys => {
      date => [datetime, {set=>1}],
      ...
    },
  }]

=head3 description

This is also ignored when validating data, but will be used by the
Human emitter to supply description.

=head2 Merging of attribute hashes

Given several attribute hashes in the schema like:

 [TYPE, AH1, AH2, AH3]

all AH1, AH2, and AH3 will be evaluated in that order:

 eval(AH1)
 eval(AH2)
 eval(AH3)

However, if AH2 keys contain prefixes, AH1 will be merged with AH2
first before evaluated. (Illustration: "*" notation indicates the
presence of merge prefix and "|" notation indicates merging).

 eval(AH1|*AH2)
 eval(AH3)

If AH3 instead contains merge prefixes then AH1 will be evaluated, and
then AH2 is merged first with AH3:

 eval(AH1)
 eval(AH2|*AH3)

If AH2 as well as AH3 contains merge prefixes, then the three will be
merged first before evaluating:

 eval(AH1|*AH2|*AH3)

So in short, unless the right hand side is devoid of merge prefixes,
merging will be done first from left to right.

Data::Schema uses L<Data::ModeMerge> to do the
merging. Data::ModeMerge allows keys on the left side to replace but
also add, subtract, remove keys from the left side. This allows schema
definition to add attributes (restrict types even more), or replace
attributes (change type restriction) as well as delete attributes
(relax type restriction).

Examples:

 [int => {divisible_by=>2}, {  divisible_by =>3}] # must be divisible by 2 & 3

 [int => {divisible_by=>2}, {'*divisible_by'=>3}] # will be merged and become:
 [int => {divisible_by=>3}                      ] # must be divisible by 3 ONLY

 [int => {divisible_by=>2}, {'!divisible_by'=>0}] # will be merged and become:
 [int => {}                                     ] # need not be divisible at all

 [int => {one_of=>[1,2,3,4,5]}, {  one_of =>[6]}] # impossible to satisfy

 [int => {one_of=>[1,2,3,4,5]}, {'+one_of'=>[6]}] # will be merged and become:
 [int => {one_of=>[1,2,3,4,5,6]}                ]

 [int => {one_of=>[1,2,3,4,5]}, {'-one_of'=>[4]}] # will be merged and become:
 [int => {one_of=>[1,2,3,  5]}                  ]

Refer to L<Data::ModeMerge> for details on merging syntax and behaviour.

=head3 Merging and hash keys

Due to merging of attribute hashes by L<Data::ModeMerge>, please be
reminded that whenever there is one of these characters on any hash
key (not just on attribute names, but also deep down in nested
hashes):

 + - . ! *

they will be B<removed> after merging.

Example:

 [hash => { "keys_regex" => { foo => [int=>{max=>7}], "^bar.*" => "str" }}
       => {"*keys_regex" => {-foo => [int=>{max=>3}]                    }}]

will be merged as:

 [hash => { "keys_regex" => { foo => [{max=>7}], "bar.*" => "str" }}]

that is, foo will also gets merged. Sometimes this might be what you
want, but sometimes it might not be. If the later is the case, you can
turn off prefix parsing:

 [hash => { "keys_regex" => { foo => [int=>{max=>7}], "^bar.*" => "str",
                              ""=>{parse_prefix=>0} }}
       => {"*keys_regex" => {-foo => [int=>{max=>4}]}}]

it will become:

 [hash => { "keys_regex" => { foo => [int=>{max=>7}], -foo => [int=>{max=>4}], "^bar.*" => "str" } }];

C<^> in regex is quite common, as an alternative to the above you can
also use C<\A>.

Please also note that the empty string key ("") is also regarded as
special by L<Data::ModeMerge>, it is called the options key which
regulate how merging should be done. Be careful not to use an empty
string as your key either. But Data::Merge provides several mechanism
to change the options key as well as the prefixes. See
L<Data::ModeMerge> for more details.

=head1 NAMING SCHEMAS FOR USE IN OTHER SCHEMAS

Schemas can be defined for use in other schemas. Example:

 {
  def => {
      single_dice_throw    => [int => {one_of => [1,2,3,4,5,6]}],
      sdt                  => "single_dice_throw", # short notation
      dice_pair_throw      => [array => {len=>2, elems=>["sdt", "sdt"]}],
      dpt                  => "dice_pair_throw",   # short notation
      throw                => [or => {alts => ["sdt", "dpt"]}],
      throws               => [array => {of => "throw"}],
  },
  type => "throws"
 }

The above schema defines six other schemas (subschemas?). These subschemas will
not be available outside of this schema.

Another way is by putting schemas in Perl hash or in YAML files and then loading
them using L<DSP::LoadSchema::Hash> or L<DSP::LoadSchema::YAMLFile>.

When evaluating "schema types" (schema that is used as type), the
schema type is expanded, and the resulting attribute hashes are merged
when necessary. For example, if we have:

 [uint => {divisible_by => 2}]

where uint is defined as:

 [int => {min => 0}]

Then when evaluating the first schema, it will be expanded into:

 [int => {min => 0} => {divisible_by => 2}]

Another example:

 [special_provinces => { "+one_of" => ["DKI"] }]

where special_provinces is:

 [str => { one_of => ["Aceh", "Djogjakarta"] }]

will become:

 [str => { one_of => ["Aceh", "Djogjakarta"] } => { "+one_of" => ["DKI"] }]

when merged will become:

 [str => { one_of => ["Aceh", "Djogjakarta", "DKI"] }]

=head1 EXPRESSION

Data::Schema supports expressions, using L<Data::Expr> minilanguage,
see L<Data::Expr::Manual::Syntax> for details on syntax. You can
specify expression in the B<check> attribute, e.g.:

 [int => {check => '$. >= 4'}]

Alternatively, expression can also be specified in other attribute's
value when that attribute's name has 'expr' parameter, e.g.:

 [int => {'min?expr' => '2+2'}]

The above two schemas are equivalent to:

 [int => {min => 4}]

Expression can refer to elements of data and (normalized) schema, and
can call functions, enabling more complex schema to be defined, for
example:

 ['array*' => {len=>2, elements => [
   ['str*', {match => '^\w+$'}],
   ['str*', {'match:expr' => '$(SCHEMA:../../0/attr_hashes/0/match)',
             'len:expr' => '2*length($(../0))'}]
 ]}]

The above schema requires a two-element array containing strings,
where the length of the second string has to be exactly twice the
length of the first, but not longer than the third string. Both have
to comply to the same regex, qr/^\w+$/.

Functions in DS can sometimes accept several types of arguments,
e.g. length(ARRAY) will return the number of elements in the ARRAY,
while length(STR) will return the number of characters in the
string. However, when an inappropriate argument is given, a Perl
exception will be thrown.

For the list of functions supported, see L<Data::Schema::Func::Std>.

Unlike in Perl, operators are also strict about their operands. For
example, you cannot do "foo" * 2 or even "1.2" * 2, but you can do 1.2
* 2. I believe this strong typing behaviour is more appropriate for a
schema language.

=cut
