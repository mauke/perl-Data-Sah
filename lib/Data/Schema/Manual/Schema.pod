# just to make PodWeaver happy at the moment
package Data::Schema::Manual::Schema;

=pod

=head1 NAME

Data::Schema::Manual::Schema - Data::Schema schema specification

=head1 VERSION

1.0

=head1 OVERVIEW

This document specifies the syntax of Data::Schema schema.


=head1 FORMS

Data::Schema schema is just a normal data structure (a hash or nested hash). You
can say that the schema is a language in which the 'program' is already parsed
(or semi-parsed). This fact gives some nice properties, which will be explained
later.

Aside from the normalized hash forms (henceforth called the 3rd form), there are
two other forms which exist to simplify the syntax: scalar (simple string, 1st
form) and array (2nd form). These two forms normalize to the hash form.

=head2 First Form (SCALAR)

 TYPE

The simplest form of schema is just a scalar (string) specifying type name. This
states that the data must be of specified type.

With this first form you cannot add any other value restrictions or anything
else, so this form is very limited.

Example:

 "int"

The schema says that data must be an integer. Examples of valid data:

 5
 -2
 undef

Note: undef is always valid except when we explicitly say that we require a
value. This is analogous to NULL in SQL being always allowed as column values
except when the column is specified with NOT NULL.

Example of invalid data:

 "int"  # not an integer, but a string
 [1]    # not an integer, an array
 {}     # not an integer, an empty hash

TYPE can also be the name of another schema. For example if you already have
defined a schema with name 'short_array' with this definition:

 [array => {maxlen => 10}]

Then you can also have a schema that says just:

 short_array

and it will also mean that the data must satisfy the 'short_array' schema.

=head2 Second Form (ARRAY)

 [TYPE, ATTRHASH1, ...]

The second form is the array form. The first element of the array is required,
the type name (or schema name). The rest is a list of attribute hashes, and is
optional.

The first form is actually equivalent to this second form:

 [TYPE]

in which no attribute hashes are specified.

Attribute hash is a mapping of attribute names and values. This further limits
the range of data values possible. Each type has its own set of known attributes,
for example all numeric types (like B<int> and B<float>) has the B<min>, B<max>,
et al. Most types have a B<one_of> attribute to limit values to the list of
values we specify, etc.

For type validation to succeed, the type requirement as well as the requirements
of all attributes (from all attribute hashes) must be satisfied.

For more details on attribute hashes, see L</"ATTRIBUTE HASH (ATTRHASH)"> section
below.

Example of second form schemas:

 [str => {one_of => [qw/A B O AB/]}]

This schema states that data must be a string, and it must either be "A", "B",
"O", or "AB". Examples of invalid data:

 []    # does not satisfy type requirement, not a string
 "C"   # a string value, but does not satisfy the one_of attribute

Another example:

 ["int", {set=>1, min=>0, divisible_by=>2}, {divisible_by=>3}]

The schema effectively says that the data must be positive and divisible by 6
(since it must be divisible by 2 AND 3). Examples of valid data:

 6
 12

Examples of invalid data:

 2       # does not satisfy the second divisible_by attribute
 -6      # satisfies all divisible_by attributes, but not the min
 undef   # set=>1 is specified so undef is not allowed

If you specify a schema name as the first element, then the attributes will be of
the base type of the schema. Example:

 # schema with name = 'even'
 [int => {divisible_by=>2}]

 # our schema
 [even => {min=>20}]

Our schema in effect says that the data must be an even number greater or equal
than 20. Since our schema is based on the B<even> schema, the attributes we can
specify is that of the B<int> type, since B<even> is defined as an int.

=head3 Shortcut notation in first form

Previously it is stated that the first form (SCALAR) cannot add any restrictions.
This is not entirely true. Aside from just specifying a type (or schema) name,
the first form can also contain a combination of one or more syntax below:

 'TYPE*'
 'TYPE[]'
 'TYPE[N]', 'TYPE[N-]', 'TYPE[-N]', 'TYPE[N-M]'
 '[TYPE1, TYPE2, ...]'
 'TYPE1|TYPE2&...'
 'TYPE1&TYPE2&...'
 '{KEY=>TYPE1, ...}'

These syntax will be expanded into the second form, thus the reason this is
called '1st form shortcuts'. They are shorter and more convenient to write.
Explanations for each of the shortcut syntax:

=head4 The * suffix (required/set=1)

The B<set => 1> attribute is very often used, so a shortcut is provided. Instead
of writing:

 [int => {set=>1}]

you can also say:

 "int*"

They are equivalent, as the shortcut notation will be converted to the array
form.

=head4 The [] suffix (array of)

 "int[]"

is a shorter way to say:

 [array => {of => "int"}]

Other example:

 "(int*)[]"        # [ array => {of=> [int=>{set=>1}]         } ]
 "((int*)[])*"     # [ array => {of=> [int=>{set=>1}], set=>1 } ]

An optional NUM, NUM-, -NUM, NUM-NUM syntax can be given to specify required
array length:

 "str[2]"         # [ array => {of=>'str', len=>2}]
 "str[1-]"        # [ array => {of=>'str', minlen=>1}]
 "str[-20]"       # [ array => {of=>'str', maxlen=>20}]
 "str[10-20]"     # [ array => {of=>'str', minlen=>10, maxlen=>20}]

=head4 The [a, b, c] notation

 "[int, str]"

is a shorter way to say:

 [array => {elems => ['int', 'str']}]    # meaning, 1st elem must be an int, 2nd must be a str

Other examples:

 "[int*, str[]]"  # [ array => {elems => [ [int=>{set=>1}], [array=>{of=>'str'}] ]} ]
 "[str, str]*"    # [ array => {elems => ['str', 'str'], set=>1} ]

=head4 The a|b notation (either)

 "str|array|hash"

is a shorter way to say:

 [either => {of => ['str', 'array', 'hash']}]

Other examples:

 "(int|(int*)[])*"   # [ either => {of => [ 'int', [array=>{of=>[int=>{set=>1}]}] ], set=>1} ]

See L<Data::Schema::Spec::v10::Type::Either> for more information on the type
'either'.

=head4 The a&b notation (all)

This is just like "a|b" notation, but for specifying 'all' instead of 'either'.
See L<Data::Schema::Spec::v10::Type::All> for more information on the type 'all'.

=head4 The {key=>sch} notation (hash keys)

 "{a=>hash, b=>int*, c=>str[]}"

is a shorter way to say:

 [hash => {keys=>{a=>'hash', b=>[int=>{set=>1}], c=>[array=>{of=>'str'}]}}]

A special key, B<*>, can be used to mean all keys. "{*=>int}" is equivalent to:

 [hash => {values_of => 'int'}]


=head2 Third Form (HASH)

 {type=>TYPE,
  attr_hashes=>[ATTRHASH, ...],
  def=>SCHEMADEFS,
  ...}

The third form (HASH) is the most complete form where you can specify everything.
The B<type> key is required, while the rest are optional.

The second form is equivalent to this third form:

 {type=>TYPE, attr_hashes=>[ATTRHASH1, ...]}

where nothing but type name and attribute hashes are specified.

The first form is equivalent to this third form:

 {type=>TYPE}

where nothing but type name is specified.

This third form allows us to define other schemas inside our schema, using the
B<def> keys, which must be a hashref of schema name and definition. This is a way
to break down or organize a complex schema into several pieces.

Example:

 {
  def => {
      single_dice_throw  => [int => {one_of => [1,2,3,4,5,6]}],
      sdt                => "single_dice_throw", # short notation
      dice_pair_throw    => [array => {len=>2, elems=>["sdt", "sdt"]}],
      dpt                => "dice_pair_throw",   # short notation
      throw              => [either => {of => ["sdt", "dpt"]}],
      throws             => [array => {of => "throw"}],
  },
  type => "throws"
 }

This schema specifies that we are accepting a list of dice throws (B<throws>).
Each B<throw> can be a single dice throw (B<sdt>) which is a number between 1 and
6, OR a throw of two dices (B<dpt>) which is a 2-element array (where each
element is a number between 1 and 6).

Examples of valid data:

 [1, [1,3], 6, 4, 2, [3,5]]

Examples of invalid data:

 1                  # not an array
 [1, [2, 3], 0]     # the third throw is invalid
 [1, [2,0,4], 4, 5] # the second throw (a dice pair throw) is invalid

=head2 Optional/conditional definition

If you put a C<?> prefix before the subschema name then it means that the
definition is optional and can be skipped if the type/schema is already defined,
e.g.:

 { def => {
       "?email"   => [str => {set=>1, match=>".+\@.+"}],
       "username" => [str => {set=>1, match=>'^[a-z0-9_]+$'}],

       "data"     => [hash => {set=>1, keys_of=>"username", values_of=>"email"}],
   },
   type => "data"
 }

In the above example, if there is already an 'email' type or schema defined at
that time, the definition will be skipped instead of a "type already exists"
error being generated. This is analogous, for example, to CREATE TABLE IF NOT
EXISTS in MySQL.

Optional definition is useful if you want to provide some defaults (a basic
validation for email) but don't mind if the validator already has something
probably better (a stricter or more precise definition of email).


=head1 TYPE

Data::Schema comes with several types out of the box, for example: B<bool>,
B<int>, B<float>, B<str>, B<array>, B<hash>, etc.

For more details on each type (what attributes it supports, etc), refer to
L<Data::Schema::Spec::v10::Type::*>.

To add a new type, see L<Data::Schema::Manual::AddingNewType>.


=head1 ATTRIBUTE HASH (ATTRHASH)

An attribute hash is a mapping of attribute names and values, or attribute
properties and their values:

 {
   attr1 => value,
   attr2 => value,
   "attr2.prop1" => value,
   "attr2.prop2" => value,
   ...
 }

Each type has its own set of known attribute names. To see what attributes a type
supports, see type handler module documentation. For example, for B<hash> type,
see L<Data::Schema::Type::Hash>.

A schema can specify more than one attribute hashes, in which each attribute hash
will be evaluated in order. However, if a key on one attribute hash contains a
merge prefix, merging will occur (see L</"Merging of attribute hashes">).

=head2 Attribute name

Attribute names must begin with letter/underscore and contain
letters/numbers/underscores only. All attributes which begin with an "_"
(underscore) will be ignored (you can use this to embed extra data for other
purposes).

=head2 Attribute properties

You can specify properties for attributes with the following syntax:

 { 'attr.propname' => value,
   ... }

Attribute properties give additional information/instruction associated with the
attribute.

There is a list of known properties. A schema is invalid if it contains an
unknown attribute property. But any property name starting with _ ("underscore")
will be ignored.

=head3 errlevel

Valid value: C<error>, C<warn>. Default if not specified is C<error>. Normally,
when attribute checking fails, an error is generated and the whole schema fails
to validate. If B<errlevel> is set to C<warn>, however, this only generates a
warning and does not cause the validation to fail.

Example:

 [str=>{minlen=>4},
       {minlen=>8, 'minlen.errlevel' => 'warn'},]

In the above example, validation fails when data is shorter than 4 characters.
When the data is between 4-7 characters, validation succeeds but with a warning.

=head3 errmsg[.LANG]

This tells the emitter that instead of the default error message from the type
handler, a custom error message is supplied. LANG is 2-code language code and can
be omitted (to mean the default/fallback language). For example:

 [str=>{match             => qr/[^A-Za-z0-9_-]/,
        'match.errmsg'    => 'Must not contain naughty characters',
        'match.errmsg.id' => 'Tidak boleh mengandung karakter aneh-aneh',
 }]

=head3 comment

This is ignored during validation.

=head3 human[.LANG]

This is also ignored when validating data, but will be used by the Human emitter
to supply description. LANG is a 2-code language code and can be omitted (to mean
the default/fallback language).

 [str=>{match            => qr/[^A-Za-z0-9_-]/,
        'match.human.en' => 'Must not contain naughty characters',
 }]

B<human> and B<errmsg> can often use the same message. The emitters can be
configured to search for one or the other.

=head3 expr

Used to specify expression. See L<"/EXPRESSION"> for more information. There is a
shortcut for this property using the '=' suffix. Example:

 [str => {'minlen.expr' => '2*3'}]

is equivalent to:

 [str => {'minlen=' => '2*3'}]

=head2 Special-purpose attributes

Normally attributes serve as a type constraint (e.g. for type string, the minlen
and maxlen attributes constraint how short/long the string can be). However there
are also some attributes that are special.

=head3 The '' (empty attribute)

This can be used to store properties that can be used generally ("general
properties"). For example:

 [str => {not_match => /(password|abcd)$/,
          minlen => 4,
          ".errmsg" => "Password not good enough!"}]

When validation fails for one or more of the attributes, the generic error
message will be used instead.

=head2 Merging of attribute hashes

Given several attribute hashes in the schema like:

 [TYPE, AH1, AH2, AH3]

all AH1, AH2, and AH3 will be evaluated in that order:

 eval(AH1)
 eval(AH2)
 eval(AH3)

However, if an attribute hash contains one or more keys with merge prefix
(explained later), the attribute hash will first be merged with the previous
attribute hash(es) prior to evaluation. For example, if AH2 keys contain merge
prefixes (notation: "*" indicates the presence of merge prefix):

 [TYPE, AH1, *AH2, AH3]

then AH1 will be merged with AH2 first before evaluated (notation: "~" signifies
merging).

 eval(AH1 ~ *AH2)
 eval(AH3)

If AH3 instead contains merge prefixes then AH1 will be evaluated, and then AH2
is merged first with AH3:

 eval(AH1)
 eval(AH2 ~ *AH3)

If AH2 as well as AH3 contains merge prefixes, then the three will be merged
first before evaluating:

 eval(AH1 ~ *AH2 ~ *AH3)

So in short, unless the right hand side is devoid of merge prefixes, merging will
be done first from left to right.

The first attribute hash should not contain any merge prefixes.

About merging and merge prefixes: Data::Schema uses L<Data::ModeMerge> to do the
merging. In merging, Data::ModeMerge allows keys on the right side hash not only
to replace but also add, subtract, remove keys from the left side. This allows
schema definition to add attributes (restrict types even more), or replace
attributes (change type restriction) as well as delete attributes (relax type
restriction). For more information, refer to the Data::ModeMerge documentation.

Examples:

 [int => {divisible_by=>2}, {  divisible_by =>3}] # must be divisible by 2 & 3

 [int => {divisible_by=>2}, {'*divisible_by'=>3}] # will be merged and become:
 [int => {divisible_by=>3}                      ] # must be divisible by 3 ONLY

 [int => {divisible_by=>2}, {'!divisible_by'=>0}] # will be merged and become:
 [int => {}                                     ] # need not be divisible at all

 [int => {one_of=>[1,2,3,4,5]}, {  one_of =>[6]}] # impossible to satisfy

 [int => {one_of=>[1,2,3,4,5]}, {'+one_of'=>[6]}] # will be merged and become:
 [int => {one_of=>[1,2,3,4,5,6]}                ]

 [int => {one_of=>[1,2,3,4,5]}, {'-one_of'=>[4]}] # will be merged and become:
 [int => {one_of=>[1,2,3,  5]}                  ]

=head3 Merging and hash keys

Due to merging of attribute hashes by L<Data::ModeMerge>, please be reminded that
whenever there is one of these characters on any hash key (not just on attribute
names, but also deep down in nested hashes):

 + - . ! *

they will be B<removed> after merging.

Example:

 [hash => { "keys_regex" => { foo => [int=>{max=>7}], "^bar.*" => "str" }}
       => {"*keys_regex" => {-foo => [int=>{max=>3}]                    }}]

will be merged to:

 [hash => { "keys_regex" => { foo => [{max=>7}], "bar.*" => "str" }}]

that is, foo will also gets merged. Sometimes this might be what you want, but
sometimes it might not be. If the later is the case, you can turn off prefix
parsing:

 [hash => { "keys_regex" => { foo => [int=>{max=>7}], "^bar.*" => "str",
                              ""=>{parse_prefix=>0} }}
       => {"*keys_regex" => {-foo => [int=>{max=>4}]}}]

it will become:

 [hash => { "keys_regex" => { foo => [int=>{max=>7}], -foo => [int=>{max=>4}], "^bar.*" => "str" } }];

C<^> is quite common as the first character in regexes. As an alternative you can
use C<\A> which will be safe in merges.

Please also note that the empty string key ("") is also regarded as special by
L<Data::ModeMerge>, it is called the options key which regulate how merging
should be done. Be careful not to use an empty string as your key either.


=head1 NAMING SCHEMAS FOR USE IN OTHER SCHEMAS

Schemas can be defined for use in other schemas. Using previous example:

 {
  def => {
      single_dice_throw  => [int => {one_of => [1,2,3,4,5,6]}],
      sdt                => "single_dice_throw", # short notation
      dice_pair_throw    => [array => {len=>2, elems=>["sdt", "sdt"]}],
      dpt                => "dice_pair_throw",   # short notation
      throw              => [either => {of => ["sdt", "dpt"]}],
      throws             => [array => {of => "throw"}],
  },
  type => "Throws"
 }

The above schema defines six other schemas (or subschemas). These subschemas will
not be available outside of this schema.

Another way is by putting schemas in Perl hash or in YAML files and then loading
them using L<Data::Schema::Plugin::LoadSchema::Hash> or
L<Data::Schema::Plugin::LoadSchema::YAMLFile>.

When evaluating "schema types" (schema that is used as type), the schema type is
expanded, and the resulting attribute hashes are merged when necessary. For
example, if we have:

 [uint => {divisible_by => 2}]

where uint is defined as:

 [int => {min => 0}]

Then when evaluating the first schema, it will be expanded into:

 [int => {min => 0} => {divisible_by => 2}]

Another example:

 [special_provinces => { "+one_of" => ["DKI"] }]

where B<special_provinces> is:

 [str => { one_of => ["Aceh", "Djogjakarta"] }]

will become:

 [str => { one_of => ["Aceh", "Djogjakarta"] } => { "+one_of" => ["DKI"] }]

when merged will become:

 [str => { one_of => ["Aceh", "Djogjakarta", "DKI"] }]


=head1 EXPRESSION

Data::Schema supports expressions, using L<Language::Expr> minilanguage, see
L<Language::Expr::Manual::Syntax> for details on the syntax. You can specify
expression in the B<check> attribute, e.g.:

 [int => {check => '$. >= 4'}]

Alternatively, expression can also be specified in other attribute's
value when that attribute's name has 'expr' property, e.g.:

 [int => {'min.expr' => '2+2'}]

The above two schemas are equivalent to:

 [int => {min => 4}]

Expression can refer to elements of data and (normalized) schema, and can call
functions, enabling more complex schema to be defined, for example:

 ['array*' => {len=>2, elements => [
   ['str*', {match => '^\w+$'}],
   ['str*', {'match.expr' => '$(SCHEMA:../../0/attr_hashes/0/match)',
             'len.expr' => '2*length($(../0))'}]
 ]}]

The above schema requires a two-element array containing strings, where the
length of the second string has to be exactly twice the length of the first, but
not longer than the third string. Both have to comply to the same regex,
qr/^\w+$/.

Functions in DS can sometimes accept several types of arguments, e.g.
length(ARRAY) will return the number of elements in the ARRAY, while length(STR)
will return the number of characters in the string. However, when an
inappropriate argument is given, a Perl exception will be thrown.

For the list of functions supported, see L<Data::Schema::Spec::v10::Func::Std>.

Unlike in Perl, operators are also strict about their operands. For example, you
cannot do "foo" * 2 or even "1.2" * 2, but you can do 1.2 * 2. I believe this
strong typing behaviour is more appropriate for a schema language.

=cut
